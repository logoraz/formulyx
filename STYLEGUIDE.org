#+title: AOFORCE Styleguide
#+author: logoraz
#+date: 2025-12-25
#+options: toc:nil
#+startup: overview
#+startup: inlineimages
:meta:
:end:


Thanks for contributing! Here are some guidelines that we follow in the codebase.

In general, we follow the Google guide: https://google.github.io/styleguide/lispguide.xml,

and ASDF's best practices guide: https://github.com/fare/asdf/blob/master/doc/best_practices.md

## Systems & Packages (ASDF)

Systems should not use ASDF's package-inferred-system class, instead they are spelled
out declaratively in the usual sense (I like this as each system.asdf acts as a comprehensive map).

I take a hybrid approach to the one file, one package, one system approach, however, allow
for other systems to be defined if and only if they are extensions, i.e. stand-alone
modules/libraries that can be loaded separately.

All files should be their own package for clarity & modularity.

This project has only one system, i.e. =aoforce.asd= and subsystem are
specified therein according to asdf's best practices guide (link above).

Additional systems are defined in the libraries directory and are their own
stand-alone systems, that can be used in conjunction to this system.

Package (=defpackge/uiop:define-package=) guide-lines
 - 1-5 symbols from a package → =:import-from=
 - 6+ symbols from a package → =:local-nicknames=
 - Utility libraries (uiop, alexandria, str) → =:local-nicknames=
 - Domain libraries (lem-core, your own packages) → =:import-from=

Package key order
 - =:use= comes first - it's the foundation (what symbols are available by default)
 - =:import-from= next - explicit external dependencies
 - =:local-nicknames= after - convenience layer for prefixing
 - =:export= near the end - what you're providing to others
 - =:documentation= last - descriptive metadata (required!)

## Alexandria and other utility libraries

You can =:import-from= these symbols in your package definition,
use the =alexandria:= package prefix, and define a package-local nickname.

Try to not use new utility functions that you don't see in the codebase yet.

For instance, we won't use =alexandria-2:line-up-first=.

Try to not use =alexandria:curry= and prefer higher-order functions.


## Dynamic bindings, functional style

Avoid dynamic symbol calls (=uiop:symbol-call=) but rethink your architecture instead.

Use =defvar= and =defparameter= for user-facing variables, but avoid
using them as global variables that store state and that are used from
functions to functions. Have a more functional style, give explicit
arguments to functions.

Example:

#+begin_src lisp

  ;; avoid this
  (defvar *var* 1)
  (defun foo ()
     ,*var*)
  (let ((*var* 2))
      (foo))

#+end_src

instead, have =foo= take one argument.


** Don't ignore compiler warnings

Please take attention to compiler warnings.


** Deprecation warnings

If you change or delete a feature, if only a variable name, you must
take care of deprecation warnings. A user should be notified that
something changed. If possible, one's old config file should not fail
loading, or it should not fail without notice. Measures can vary. 

Ideas:

- don't delete or rename a =defvar=, a =defparameter= or a function, but leave
  it and if it is used, signal a warning or an error. Add a =;; DEPRECATED= comment
  with the date of the comment.
- document the breaking change on the "next release changelog" issue.


** Documentation

Write thorough docstrings to interactive commands,
give meaningful documentation to important functions, give a
high-level overview in packages and comments (the "why", not the
"how"). Use the `:documentation` option of packages, generic functions
and CLOS slots.

Please also contribute to documentation:

for now, open an issue about it so we don't forget to do it, thank you.


** Errors

=error= is for internal errors.


** File layout

Variables and parameters (=defvar=, =defparameter=) should be grouped
and appear near the top of the file, before conditions, classes and
functions.


** Git and pull requests

Please rebase and squash small commits together.

When your changes are about a module or a feature, the commit message should say it upfront, 
for example:

    module/feature: add k to discard changes of unstaged files


** Loop

Loop keywords are written as keywords, with a colon =:= as follows:

#+begin_src lisp

  (loop :for key :in … )

#+end_src


** Macros, backquote, comma

Don't write long macros, use the "call-with-" pattern.

Avoid defining lists with quote, backquote and comma, only do it when
you know you need them. Prefer using the =list= constructor.


** User-visible variables names

Parameters that can be changed by the user should not have a "-p"
suffix. Keep them for the functions' key arguments.

